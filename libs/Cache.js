// Generated by CoffeeScript 1.10.0
(function() {
  var Cache, Promise, _;

  _ = require('lodash');

  Promise = require('bluebird');

  Cache = (function() {
    function Cache(opts1, debug, sync_key) {
      this.opts = opts1 != null ? opts1 : {};
      this.debug = debug != null ? debug : false;
      this.sync_key = sync_key != null ? sync_key : '_cacheSync';
      this.opts = _.assign({
        duplicate: false,
        expired: null
      }, this.opts);
      this.cache = null;
    }

    Cache.prototype.log = function(msg) {
      if (this.debug === true) {
        return console.log(msg);
      }
    };

    Cache.prototype.use = function(scheme) {
      return this.cache = scheme();
    };

    Cache.prototype.set = function(name, opts, alias) {
      if (!_.has(this.cache, 'set') || !_.has(this.cache, 'get')) {
        throw new Error('Please set a cache scheme');
      }
      return (function(_this) {
        return function(req, res, next) {
          var _cache, is_init, sync;
          sync = _.has(req.query, _this.sync_key);
          if (_.isFunction(name)) {
            _cache = function(obj) {
              return _this.create(Promise.resolve(name(obj)), function() {
                return [sync, _.assign(this.opts, opts)];
              });
            };
          } else {
            _cache = _this.create(Promise.resolve(name), function() {
              return [sync, _.assign(this.opts, opts)];
            });
          }
          is_init = false;
          if (!_.has(req, 'cache')) {
            is_init = true;
            req.cache = {};
          }
          if (alias != null) {
            req.cache[alias] = _cache;
          } else if (is_init === false) {
            next(new Error('You have to set alias of every cache when use multiple cache in one route'));
            return;
          } else {
            req.cache = _cache;
          }
          return next();
        };
      })(this);
    };

    Cache.prototype.create = function(get_name, get_config) {
      return {
        get_or_create: (function(_this) {
          return function(func) {
            return get_name.then(function(name) {
              var opts, ref, sync;
              ref = get_config(), sync = ref[0], opts = ref[1];
              if (sync === true) {
                _this.log(name + " force sync");
                return _this.getData(name, func, sync, opts);
              } else {
                _this.log(name + " get from cache");
                return _this.cache.get(name).then(function(data) {
                  if (data != null) {
                    _this.log(name + " cache hit");
                    return Promise.resolve(data);
                  } else {
                    _this.log(name + " cache miss");
                    return _this.getData(name, func, sync, opts);
                  }
                });
              }
            });
          };
        })(this)
      };
    };

    Cache.prototype.getData = function(name, func, sync, opts) {
      return func((function(_this) {
        return function(err) {
          return _this.error(err, name, sync, opts);
        };
      })(this), (function(_this) {
        return function(data) {
          return _this.success(data, name, opts);
        };
      })(this));
    };

    Cache.prototype.error = function(err, name, sync, opts) {
      if (opts.duplicate && !sync) {
        this.log(name + " get from duplicate");
        return this.cache.get(name + "-duplicate").then((function(_this) {
          return function(data) {
            if (data != null) {
              _this.log(name + " duplicate hit");
              return Promise.resolve(data);
            } else {
              _this.log(name + " duplicate miss");
              return Promise.reject(err);
            }
          };
        })(this))["catch"](function(_err) {
          return Promise.reject(_err);
        });
      } else {
        return Promise.reject(err);
      }
    };

    Cache.prototype.success = function(data, name, opts) {
      var arr;
      arr = [this.cache.set(name, data, opts.expired)];
      if (opts.duplicate === true) {
        this.log(name + " create duplicate");
        arr.push(this.cache.set(name + "-duplicate", data, null));
      }
      return Promise.all(arr).then(function() {
        return Promise.resolve(data);
      });
    };

    return Cache;

  })();

  module.exports = Cache;

}).call(this);

//# sourceMappingURL=Cache.js.map
